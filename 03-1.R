 # 03-1.r 변수
 # 2019-06-10 Mon
 # Author: 홍연표
 # Comment: 변수사용례와 필기
 # 스칼라와 벡터
 # rm(list=ls())과 gc() 명령어
 # 연산자의 우선 순위


#변수는

# 문자로 시작 가능
a <- -1
a

# 문자와 숫자 가능
a1 <- 10
a1

#.으로 시작 가능
.x <- 3
.x

#그러나 숫자로는 시작 불가능.
1a <- 40

#.다음 숫자도 변수 불가능 -> .2는 0.2
.2


a <- 10 # 스칼라


# combine
var1 <- c(1,2,3,4,5,6,7) # 벡터
var1

# 스칼라와 벡터의 차이점은? 스칼라는 크기는 있는데 방향은 없는 값. 벡터는 크기도 있고, 방향도 있는 값 방향은 순서를 말한다. 스칼라는 0차원 데이터 라고 말하고 벡터는 1차원 데이터. 0차원은 점! 1차원은 선! 2차원은 면! 3차원은 입체! 3차원의 대표 적인 예는 영상출력방식인 RGB

# 스칼라가 모이면 벡터, 벡터가 모이면 2차원.. 2차원이 모이면 3차원!

# 최신언어의 장점이 바로 벡터의 연산이 매우 빠르게! 가능하다는 점이다!

var1*2 #이걸 벡터연산이라고 부른다.
var1+1

var2 <- c(1:7)
var2


var3 <- seq(1,7) #sequence의 약자 (연속)
var3


var4 <- seq(1,10,by = 2) 
var4

#NA는결측치 
var5 <- NA  # NA는 결측치
var5
var5+10 
#언뜻봐선 없는거 +10 이어서 10 나올것 같으나 결측치 이므로 그대로 NA가 나옴.

var6 <- null 
#null은 초기화 되지 않은 데이터를 뜻한다.

#차원에 따라 R에서는 0차원 스카라, 1차원 벡터, 2차원 행렬과 데이터프레임, 다차원 배열과 리스트로 표현한다.

#행렬은 한가지 변수, 대부분 숫자 이고, 데이터 프레임은 숫자와 문자 등 다양한 변수 타입으로 구성된 것.


#할당 연산자 <-가 =보다 우선 순위가 높다.  *,+ 중 *를 먼저하듯.

#a는 b인데?

#변수를 없애고 싶을 땐 rm(list=ls())를 사용한다. rm은 remove의 약자 그러나 휴지통으로 감.. gc()는 쓰레기통 비우는 명령어. garbage collection의 준말

a <- b = 5  #값이 있는 것만 넣을 수 있으므로 변수가 없는 상태에서 넣는 경우 오류로 나온다.


a = b <- 55 
a





 # (2) 문자열(string)
 # (2-1) 스칼라 문자열
str1 <- "a"
str2 <- "abcd"
str3 <- "문자열"
str4 <- 'hello string!!'


# 진리값(logical)

a = TRUE
a
b = FALSE
b

c <- a | b               #OR 연산자
c

d <- a & b               #and 연산자
d


# 요인 (Factor)은 스칼라다.

grade <- factor("A",c("A","B","C"))
grade

sex <- factor("male",c("male","female"))
sex

nlevels(sex)
nlevels(grade)

levels(grade)
levels(sex)

# (2-2) 벡터 문자열 combine의 약자인 c를 활용
#index 요소 활용하기 [] 아래와 같은 벡터에서 var3[숫자] 하면 숫자에 맞는 번째의 데이터가 나온다.

var3 <- c("a","b","c","d")
var3


var3[1] #요소 한개만 접근  "a"
var3[2] #"b"
var3[3] #"c"

var3[c(1,3)]   #"a","c" #요소 두개이상 접근 
var3[c(1,2,4)] #"a","b","d"
var3[2:3] #"b","c"

var3[-1] #"b","c","d" 맨 앞에꺼 뺴고 출력.

var4 <- c(10,20,30)
names(var4) <- c("국어","영어","수학")
var4


 # [3] 행렬 : 2차원, m(행),n(열)
z <- matrix(c(1,2,3,4,5,6,7,8,9,10,11,12),nrow = 3)
z
#      [,1] [,2] [,3] [,4]
#[1,]    1    4    7   10
#[2,]    2    5    8   11
#[3,]    3    6    9   12

z <- matrix(c(1,2,3,4,5,6,7,8,9,10,11,12),nrow = 3,byrow = T) #byrow는 숫자를 행방향으로 채우라는 명령어이다.
z
#     [,1] [,2] [,3] [,4]
#[1,]    1    2    3    4
#[2,]    5    6    7    8
#[3,]    9   10   11   12


x<- matrix(c(1:12),ncol = 4)
x
#      [,1] [,2] [,3] [,4]
#[1,]    1    4    7   10
#[2,]    2    5    8   11
#[3,]    3    6    9   12


# 행렬의 요소 접근 행렬[행,열]
z
z[1,1] #한가지 요소만 추출. 몇행 몇열에 있는걸 빼라

z[1,2]


b <- z[c(1,2),c(1,2)] #범위로 행열을 추출하기. 2행까지와 2열까지 추출해라. 행열로
b
#      [,1] [,2]
#[1,]    1    2
#[2,]    5    6

z[1,1:3]
# [1] 1 2 3

z[2:3, ] #범위를 지정해주지 않으면 전부 다로 계산한다. 비었을경우 디폴트는 전부.

 #      [,1] [,2] [,3] [,4]
 #[1,]    5    6    7    8
 #[2,]    9   10   11   12

z[-1,-1] #1행과 1열을 제외하겠다.
z[-3,-1] #3행과 1열을 제외하겠다.


#행열의 연산
x<- matrix(c(1,2,3,4,5,6,7,8,9),nrow = 3)
x
x+x
#      [,1] [,2] [,3]
#[1,]    2    8   14
#[2,]    4   10   16
#[3,]    6   12   18

x*x #스칼라의 사칙연산 처럼 요소끼리 곱해졌음.
#      [,1] [,2] [,3]
#[1,]    1   16   49
#[2,]    4   25   64
#[3,]    9   36   81

x/2 #매트릭스끼리 아니어도 연산 가능.
#     [,1] [,2] [,3]
#[1,]  0.5  2.0  3.5
#[2,]  1.0  2.5  4.0
#[3,]  1.5  3.0  4.5

x %*% x #행렬곱셈(매트릭스곱셈) 연산자
#     [,1] [,2] [,3]
#[1,]   30   66  102
#[2,]   36   81  126
#[3,]   42   96  150

#  a b c         a b c        aa+bd+cg ab+be+ch ac+bf+ci
#( d e f ) %*% ( d e f ) =  ( da+ed+fg db+ee+fh dc+ef+fi )
#  g h i         g h i        ga+hd+ig gb+he+ih gc+hf+ii



# (M*N)행렬 * (N*L)행렬 = (M*L)행렬이 된다 


 # 역행렬 : solve(행렬)
x <- matrix(c(1:4),ncol=2)
x


  y <-  solve(x)
#     [,1] [,2]
#[1,]   -2  1.5
#[2,]    1 -0.5
    #역행렬은 뭐냐? A*A^-1=A^-1*A=E 를 하게하는 A^-1를 역행렬이라 한다.
    #E행렬은, (1 0 0) 모양의 행렬을 뜻한다. 
    #         (0 1 0)
    #         (0 0 1)


x %*% y
 #     [,1] [,2]
 #[1,]    1    0
 #[2,]    0    1

 # 전치행렬 : 행과 열을 뒤집은 행열. transpose의 준말 t()
x <- matrix(c(1:9),ncol=3)
t(x)
x

ncol(x) # 행렬의 열의 갯수
nrow(x) # 행렬의 행의 갯수




 # [4] 데이터 프레임

d <- data.frame("분반"=c(1,2,3,4,5),
                "학생수"=c(2,4,6,8,10),
                "평균등급"=c('a','b','c','d','e'),
                "반호칭"=c("바보","멍충이","메롱","헤헤","낄낄"))

d
#데이터프레임의 요소 접근
# (데이터프레임)$(열이름)

d$반호칭

d


d[1:3,1:3]
d[c(1,4),1:4]
d[-1,-1]



 # [5] 배열(array) : n차원 행열이다.


 # 2차원 배열(array)은 행렬(matrix)과 동일하다.

 a <- matrix(c(1:12),ncol = 4)
 a
 
 # 3차원 array는 array(벡터,dim=c(행,열,면))
 # dim = c(행,열,면), 면의 갯수는 matrix의 갯수이다.
 a <- array(1:12,dim = c(3,4)) #dim 은 디멘션의 준말 (차원)
 a
 
 b <- array(1:12,dim = c(2,2,3))
 b
 
 b[1,1,1] # [1] 1
 b[1,2,3] # [1] 11
 b[,-1,2:3]
 
 
 # [6] 리스트 (list)
 # list(key=value,key=value....)
 
 x <- list(name="kim", height=170, weight=60, score=c(10,20,30), born=1994)
 x 
 
 x$name
 x$height
 x$weight  
 
 x[1]
 x[[1]] 
 
 
 
 #제어문 : IF, FORm WHILE
 #[1] IF문 if 조건이 true 면 문장1, 아니면 문장2 else가 없을경우는 빠져나옴.
 # if (조건) { 문장1 }
 # else { 문장2 }
 
 h<-10
  
 if (h>90) {"합격"} else { "불합격" }
 
 cond <- TRUE
 if(cond) {
   print ("TRUE")
   print ("you WIn!!!")
 }else{
   print("false")
   print("you lost!!!")
   }

 
  # [2] FOR문 : 반복문
 for (i in 1:10) {
   print(i)
 }
 
 
 a <- c(1:100)
 sum(a) 

 #1부터 100까지 합을 for문을 사용하여 구하세요. 변수 사용은 자유

 result <- 0 
 mean <- 0
  for (i in 1:100) {
   result <- result+i
 }
 
 print(result)
 
 #처음 0이었던 result값이 1을 더하고 다시 2를 만나고.,.,. 식으로.,..
 
 print(result)/100 
 print(mean) 


 # [3] WHILE문 :  조건을 사용한 무한 반복
 cond <- TRUE
 i <- 1
 while(i<101) {
   print(i)
   i <- i+1
 }
 # while(true) {} -> 무한반복
 
 #함수
 
 a <- 10
 b <- 20
 c <- a+b
 c
 a <- 50 
 b <- 60
 c <- a+b
 c

 #반복적인 코드는 비효율적
 #함수명 <- function(인자1,인자2,....)
 
 add <- function(a,b)
 { 
   c = a + b
   return(c)
 }

 d <- add(10,20)  #함수를 쓰는걸 호출한다고 부름. 
 d 
 
 e <- add(50,60)
 e 
 
 # 예제: 1+10, 2+20, 3+30, ..... 10+100,.... 100+1000
 
 result<-0 
 for (i in 1:100) {
   result <- result + add(i,10*i)
   print(result)
 }

 sum_func <- function(a)
 {
   print(a)
   len <-length(a)
   #a[1]
   b <- 0
   for(i in 1:len) {
     b <- b + a[i]
   }
   return(b)
 } 
 sum_func(c(1,2,3,4,5))
 
 mean_func <- function(a)
 {
   print(a)
   len <-length(a)
   #a[1]
   b <- 0
   for(i in 1:len) {
     b <- b + a[i]
   }
   return(b/len)
 } 
 mean_func(1:8) 

  ?mean
 
 